#!/usr/bin/env python3

def iroot(k, n):
    """Return the integer k-th root of n and a boolean indicating if it's exact."""
    low = 0
    high = 1 << ((n.bit_length() + k - 1) // k + 1)
    while low < high:
        mid = (low + high) // 2
        if mid**k < n:
            low = mid + 1
        else:
            high = mid
    if low**k == n:
        return low, True
    return low - 1, False

def main():
    # Given RSA parameters
    n = 17258212916191948536348548470938004244269544560039009244721959293554822498047075403658429865201816363311805874117705688359853941515579440852166618074161313773416434156467811969628473425365608002907061241714688204565170146117869742910273064909154666642642308154422770994836108669814632309362483307560217924183202838588431342622551598499747369771295105890359290073146330677383341121242366368309126850094371525078749496850520075015636716490087482193603562501577348571256210991732071282478547626856068209192987351212490642903450263288650415552403935705444809043563866466823492258216747445926536608548665086042098252335883
    ct = 243251053617903760309941844835411292373350655973075480264001352919865180151222189820473358411037759381328642957324889519192337152355302808400638052620580409813222660643570085177957

    # Compute the cube root of the ciphertext
    m, exact = iroot(3, ct)
    if not exact:
        raise ValueError("Ciphertext is not a perfect cube")
    
    # Convert the integer back to bytes and decode
    flag_bytes = m.to_bytes((m.bit_length() + 7) // 8, 'big')
    flag = flag_bytes.decode()
    print(flag)

if __name__ == "__main__":
    main()
